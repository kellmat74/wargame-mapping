<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactical Map Configuration</title>
    <!-- Leaflet.js for map preview -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <style>
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
        }

        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        h1 {
            margin: 0 0 20px 0;
            color: #00d4ff;
            font-size: 24px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .panel {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #0f3460;
        }

        .panel h2 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .input-field {
            flex: 1;
            min-width: 150px;
        }

        .input-field label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }

        .input-field input, .input-field select {
            width: 100%;
            padding: 10px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #fff;
            font-size: 14px;
        }

        .input-field input:focus, .input-field select:focus {
            outline: none;
            border-color: #00d4ff;
        }

        /* Shift Controls */
        .shift-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .shift-row {
            display: flex;
            gap: 5px;
        }

        .shift-btn {
            width: 60px;
            height: 40px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .shift-btn:hover {
            background: #0f3460;
            border-color: #00d4ff;
        }

        .shift-btn:active {
            background: #00d4ff;
            color: #000;
        }

        .shift-center {
            width: 60px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #666;
        }

        .shift-distance {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .shift-distance label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 8px 12px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            font-size: 12px;
        }

        .shift-distance input[type="radio"] {
            accent-color: #00d4ff;
        }

        .shift-distance label:has(input:checked) {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        /* Current Config Display */
        .config-display {
            background: #0d1b2a;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .config-display .label {
            color: #888;
            display: inline-block;
            width: 120px;
        }

        .config-display .value {
            color: #00d4ff;
        }

        .config-display .value.coords {
            color: #4ade80;
        }

        /* Buttons */
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #00d4ff;
            color: #000;
        }

        .btn-primary:hover {
            background: #00b8e6;
        }

        .btn-secondary {
            background: #0f3460;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #1a4a7a;
        }

        .btn-warning {
            background: #f59e0b;
            color: #000;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-success {
            background: #10b981;
            color: #fff;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-success:disabled {
            background: #4a5568;
            cursor: not-allowed;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* Command Output */
        .command-output {
            background: #0d1b2a;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
            color: #4ade80;
            display: none;
        }

        .command-output.visible {
            display: block;
        }

        /* Rotation Slider */
        .rotation-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .rotation-control input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #0f3460;
            border-radius: 3px;
            outline: none;
        }

        .rotation-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .rotation-value {
            min-width: 60px;
            text-align: center;
            font-size: 18px;
            color: #00d4ff;
        }

        /* Region info */
        .region-info {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        /* Copy button */
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 11px;
            background: #0f3460;
            border: none;
            border-radius: 3px;
            color: #fff;
            cursor: pointer;
        }

        .copy-btn:hover {
            background: #1a4a7a;
        }

        .command-wrapper {
            position: relative;
        }

        /* Status messages */
        .status {
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 13px;
            display: none;
        }

        .status.success {
            display: block;
            background: rgba(74, 222, 128, 0.1);
            border: 1px solid #4ade80;
            color: #4ade80;
        }

        .status.info {
            display: block;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid #00d4ff;
            color: #00d4ff;
        }

        .status.warning {
            display: block;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid #f59e0b;
            color: #f59e0b;
        }

        /* MGRS Region Display */
        .mgrs-display {
            background: #0d1b2a;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
        }

        .mgrs-title {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .mgrs-squares {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .mgrs-square {
            padding: 10px 15px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mgrs-square.available {
            background: rgba(74, 222, 128, 0.1);
            border-color: #4ade80;
            color: #4ade80;
        }

        .mgrs-square.missing {
            background: rgba(245, 158, 11, 0.1);
            border-color: #f59e0b;
            color: #f59e0b;
        }

        .mgrs-square.primary {
            border-width: 2px;
        }

        .mgrs-square .icon {
            font-size: 14px;
            margin-right: 4px;
        }

        .mgrs-square .label {
            font-size: 10px;
            color: #888;
            margin-left: 5px;
        }

        /* Existing regions dropdown */
        .existing-regions {
            margin-top: 15px;
        }

        .existing-regions select {
            width: 100%;
            padding: 10px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: #1a1a2e;
            color: #fff;
            font-size: 14px;
        }

        /* Navigation tabs */
        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .nav-tab {
            padding: 10px 20px;
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 4px;
            color: #aaa;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.2s;
        }

        .nav-tab:hover {
            border-color: #00d4ff;
            color: #fff;
        }

        .nav-tab.active {
            background: #0f3460;
            color: #00d4ff;
            border-color: #00d4ff;
        }

        /* Preview Map Styles */
        #previewMap {
            height: 400px;
            width: 100%;
            border-radius: 4px;
            background: #0d1b2a;
        }

        .preview-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: #0d1b2a;
            border-radius: 4px;
        }

        .preview-stat {
            display: flex;
            flex-direction: column;
        }

        .preview-stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }

        .preview-stat-value {
            font-size: 14px;
            color: #00d4ff;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .preview-hint {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .leaflet-container {
            background: #0d1b2a;
        }

        /* Multi-Map Layout Styles */
        .layout-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .layout-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border: 2px solid #0f3460;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 120px;
        }

        .layout-option:hover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.05);
        }

        .layout-option.selected {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .layout-option input[type="radio"] {
            display: none;
        }

        .layout-diagram {
            display: flex;
            gap: 2px;
            margin-bottom: 10px;
        }

        .layout-diagram.vertical {
            flex-direction: column;
        }

        .layout-diagram.grid-2x2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
        }

        .map-box {
            background: #0f3460;
            border: 1px solid #00d4ff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #00d4ff;
            font-size: 12px;
        }

        .map-box.single {
            width: 68px;
            height: 44px;
        }

        .map-box.half-h {
            width: 34px;
            height: 44px;
        }

        .map-box.half-v {
            width: 68px;
            height: 22px;
        }

        .map-box.quarter {
            width: 34px;
            height: 22px;
        }

        .layout-label {
            font-size: 12px;
            color: #fff;
            font-weight: 600;
        }

        .layout-size {
            font-size: 11px;
            color: #888;
            margin-top: 3px;
        }

        /* Sheet label markers for multi-map preview */
        .sheet-label-icon {
            background: transparent;
        }
        .sheet-label {
            background: rgba(0, 212, 255, 0.9);
            color: #000;
            font-weight: bold;
            font-size: 20px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #000;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Wargame Map Generator</h1>

        <div class="nav-tabs">
            <a href="/" class="nav-tab active">Detailed Map</a>
            <a href="/game-map" class="nav-tab">Game Map Conversion</a>
        </div>

        <!-- Instructions -->
        <div class="panel" style="background: #0d2137; border-color: #00d4ff;">
            <h2 style="cursor: pointer;" onclick="toggleInstructions()">
                üìã Quick Start Guide <span id="instructionsToggle" style="float: right; font-size: 12px;">‚ñ∂</span>
            </h2>
            <div id="instructionsContent" style="display: none;">
                <div style="font-size: 13px; line-height: 1.6; color: #ccc;">
                    <p style="margin: 0 0 15px 0;"><strong style="color: #00d4ff;">Step 1: Configure Your Map</strong></p>
                    <ul style="margin: 0 0 15px 0; padding-left: 20px;">
                        <li>Enter a <strong>Map Name</strong> (used for output filenames)</li>
                        <li>Set the <strong>Center Location</strong> - paste coordinates in any format:
                            <ul style="margin: 5px 0; font-size: 11px; color: #888;">
                                <li>Decimal: 49.7289, 37.5767 (Google Maps format)</li>
                                <li>DMS: 24¬∞08'51"N 120¬∞40'25"E</li>
                                <li>MGRS: 51PTT1234567890 or 51P TT 12345 67890</li>
                            </ul>
                        </li>
                        <li>Adjust <strong>Bearing at Top</strong> if needed (0¬∞ = North up, 90¬∞ = East up, etc.)</li>
                    </ul>

                    <p style="margin: 0 0 15px 0;"><strong style="color: #00d4ff;">Step 2: Generate</strong></p>
                    <ul style="margin: 0 0 15px 0; padding-left: 20px;">
                        <li>Click <strong>Generate Map</strong> to create your map</li>
                        <li>MGRS data is extracted automatically from country PBFs</li>
                        <li>Progress is shown in real-time below the button</li>
                    </ul>

                    <p style="margin: 0 0 10px 0;"><strong style="color: #ff6b6b;">Prerequisite: Country Data</strong></p>
                    <ul style="margin: 0 0 15px 0; padding-left: 20px; font-size: 12px;">
                        <li>Download the country PBF once from <a href="https://download.geofabrik.de/asia.html" target="_blank" style="color: #00d4ff;">Geofabrik</a></li>
                        <li>Save to: <code style="background: #1a1a2e; padding: 2px 6px; border-radius: 3px;">data/geofabrik/{country}-latest.osm.pbf</code></li>
                        <li>Available regions auto-detected from downloaded PBF files</li>
                    </ul>

                    <p style="margin: 0 0 10px 0;"><strong style="color: #00d4ff;">Step 3: Find Your Output</strong></p>
                    <ul style="margin: 0; padding-left: 20px;">
                        <li>SVG map: <code style="background: #1a1a2e; padding: 2px 6px; border-radius: 3px;">output/{country}/{name}/{name}_tactical.svg</code></li>
                        <li>Hex data: <code style="background: #1a1a2e; padding: 2px 6px; border-radius: 3px;">output/{country}/{name}/{name}_hexdata.json</code></li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Map Name -->
        <div class="panel">
            <h2>Map Name</h2>
            <div class="input-group">
                <div class="input-field">
                    <label>Map Name</label>
                    <input type="text" id="mapName" value="tactical_map">
                    <div class="region-info">Used for output filenames (no spaces recommended)</div>
                </div>
            </div>
        </div>

        <!-- Center Location -->
        <div class="panel">
            <h2>Center Location</h2>
            <div class="input-group">
                <div class="input-field" style="flex: 2;">
                    <label>Paste Coordinates (auto-detects format)</label>
                    <input type="text" id="coordPaste" placeholder="Decimal, DMS, or MGRS (e.g. 51PTT1234567890)" style="font-family: monospace;">
                    <div class="region-info">Supported: Decimal (24.14, 120.67) | DMS (24¬∞08'51"N 120¬∞40'25"E) | MGRS (51PTT1234567890)</div>
                </div>
            </div>
            <!-- Hidden lat/lon inputs for state management -->
            <input type="hidden" id="centerLat" value="">
            <input type="hidden" id="centerLon" value="">
        </div>

        <!-- Map Preview -->
        <div class="panel">
            <h2>Map Preview</h2>
            <div id="previewMap"></div>
            <div class="preview-stats" id="previewStats">
                <div class="preview-stat">
                    <span class="preview-stat-label">Coverage</span>
                    <span class="preview-stat-value" id="statCoverage">--</span>
                </div>
                <div class="preview-stat">
                    <span class="preview-stat-label">Hex Count</span>
                    <span class="preview-stat-value" id="statHexCount">1,222 hexes</span>
                </div>
                <div class="preview-stat">
                    <span class="preview-stat-label">Print Size</span>
                    <span class="preview-stat-value" id="statPrintSize">34" x 22"</span>
                </div>
                <div class="preview-stat">
                    <span class="preview-stat-label">Rotation</span>
                    <span class="preview-stat-value" id="statRotation">0¬∞ (North up)</span>
                </div>
            </div>
            <div class="preview-hint">
                Click on the map to recenter. The rectangle shows the map boundary with current rotation.
            </div>
        </div>

        <!-- Bearing at Top -->
        <div class="panel">
            <h2>Bearing at Top</h2>
            <div class="rotation-control">
                <input type="range" id="rotationSlider" min="0" max="359" value="0">
                <span class="rotation-value" id="rotationValue">0</span>¬∞
                <span id="rotationDirection" style="color: #888; font-size: 14px;">(North)</span>
            </div>
            <div class="region-info" style="margin-top: 10px;">
                0¬∞ = North at top, 90¬∞ = East at top, 180¬∞ = South at top, 270¬∞ = West at top
            </div>
        </div>

        <!-- Multi-Map Layout -->
        <div class="panel">
            <h2>Multi-Map Layout</h2>
            <div class="multi-map-options">
                <div class="layout-grid">
                    <!-- Single Map (default) -->
                    <label class="layout-option selected" data-count="1" data-orientation="single">
                        <input type="radio" name="mapLayout" value="single" checked>
                        <div class="layout-diagram">
                            <div class="map-box single">A</div>
                        </div>
                        <span class="layout-label">Single Map</span>
                        <span class="layout-size">34" √ó 22"</span>
                    </label>

                    <!-- 2 Maps - Short Edge -->
                    <label class="layout-option" data-count="2" data-orientation="short_edge">
                        <input type="radio" name="mapLayout" value="2-short">
                        <div class="layout-diagram">
                            <div class="map-box half-h">A</div>
                            <div class="map-box half-h">B</div>
                        </div>
                        <span class="layout-label">2 Maps (wide)</span>
                        <span class="layout-size">68" √ó 22"</span>
                    </label>

                    <!-- 2 Maps - Long Edge -->
                    <label class="layout-option" data-count="2" data-orientation="long_edge">
                        <input type="radio" name="mapLayout" value="2-long">
                        <div class="layout-diagram vertical">
                            <div class="map-box half-v">A</div>
                            <div class="map-box half-v">B</div>
                        </div>
                        <span class="layout-label">2 Maps (tall)</span>
                        <span class="layout-size">34" √ó 44"</span>
                    </label>

                    <!-- 4 Maps - 2x2 Grid -->
                    <label class="layout-option" data-count="4" data-orientation="grid">
                        <input type="radio" name="mapLayout" value="4-grid">
                        <div class="layout-diagram grid-2x2">
                            <div class="map-box quarter">A</div>
                            <div class="map-box quarter">B</div>
                            <div class="map-box quarter">C</div>
                            <div class="map-box quarter">D</div>
                        </div>
                        <span class="layout-label">4 Maps (2√ó2)</span>
                        <span class="layout-size">68" √ó 44"</span>
                    </label>
                </div>
            </div>
            <div class="region-info" style="margin-top: 10px;">
                Multi-map layouts share hex edges for seamless tabletop play. Center point is the center of all maps combined.
            </div>
        </div>

        <!-- Fine-Tune Position -->
        <div class="panel">
            <h2>Fine-Tune Position</h2>
            <div class="shift-controls">
                <div class="shift-row">
                    <button class="shift-btn" onclick="shift('up')">‚Üë</button>
                </div>
                <div class="shift-row">
                    <button class="shift-btn" onclick="shift('left')">‚Üê</button>
                    <div class="shift-center">‚äï</div>
                    <button class="shift-btn" onclick="shift('right')">‚Üí</button>
                </div>
                <div class="shift-row">
                    <button class="shift-btn" onclick="shift('down')">‚Üì</button>
                </div>
            </div>
            <div class="shift-distance">
                <label><input type="radio" name="shiftDist" value="100"> 100m</label>
                <label><input type="radio" name="shiftDist" value="500"> 500m</label>
                <label><input type="radio" name="shiftDist" value="1000" checked> 1km</label>
                <label><input type="radio" name="shiftDist" value="5000"> 5km</label>
            </div>
            <div class="region-info" style="margin-top: 10px;">
                Shifts are relative to map orientation (up = toward top of map)
            </div>
        </div>

        <!-- Required MGRS Squares -->
        <div class="panel">
            <h2>Required MGRS Squares</h2>
            <div id="mgrsSquares" class="mgrs-squares">
                <div style="color: #888; font-style: italic;">Enter coordinates to see required MGRS squares</div>
            </div>
        </div>

        <!-- Generate -->
        <div class="panel">
            <h2>Generate</h2>
            <div class="button-row">
                <button class="btn btn-primary" onclick="saveConfig()">Save Configuration</button>
                <button class="btn btn-success" id="generateBtn" onclick="generateMap()">Generate Map</button>
                <button class="btn btn-secondary" onclick="resetToDefaults()">Reset</button>
                <button class="btn btn-danger" id="stopServerBtn" onclick="stopServer()" style="display: none;">Stop Server</button>
                <span id="versionLabel" style="margin-left: auto; font-size: 12px; color: #666; align-self: center;"></span>
            </div>
            <div class="region-info" style="margin-top: 15px;" id="serverModeHint">
                <span id="serverStatus">Checking server...</span>
            </div>
            <div class="status" id="statusMsg"></div>

            <!-- Progress Output -->
            <div id="progressContainer" style="display: none; margin-top: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: #00d4ff;">Generation Progress</strong>
                    <button class="btn btn-secondary" onclick="clearProgress()" style="padding: 4px 10px; font-size: 11px;">Clear</button>
                </div>
                <div id="progressOutput" style="
                    background: #0a0a0a;
                    border: 1px solid #333;
                    border-radius: 4px;
                    padding: 12px;
                    font-family: 'Monaco', 'Menlo', monospace;
                    font-size: 11px;
                    max-height: 300px;
                    overflow-y: auto;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                    color: #0f0;
                "></div>
            </div>
        </div>

        <!-- Map Settings (collapsible) -->
        <div class="panel">
            <h2 style="cursor: pointer;" onclick="toggleSettings()">
                Map Settings <span id="settingsToggle" style="float: right; font-size: 12px;">‚ñ∂</span>
            </h2>
            <div id="settingsContent" style="display: none;">
                <!-- Grid Settings -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 12px; color: #aaa; text-transform: uppercase;">Grid</label>
                    <div class="input-group">
                        <div class="input-field">
                            <label>Hex Size (m)</label>
                            <input type="number" id="hexSizeM" step="10" value="250">
                            <div class="region-info">Flat edge to flat edge</div>
                        </div>
                        <div class="input-field">
                            <label>Grid Width (hexes)</label>
                            <input type="number" id="gridWidth" step="1" value="47">
                        </div>
                        <div class="input-field">
                            <label>Grid Height (hexes)</label>
                            <input type="number" id="gridHeight" step="1" value="26">
                        </div>
                    </div>
                </div>

                <!-- Contour Settings -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 12px; color: #aaa; text-transform: uppercase;">Contours</label>
                    <div class="input-group">
                        <div class="input-field">
                            <label>Contour Interval (m)</label>
                            <input type="number" id="contourInterval" step="5" value="20">
                            <div class="region-info">Regular contour spacing</div>
                        </div>
                        <div class="input-field">
                            <label>Index Interval (m)</label>
                            <input type="number" id="indexContourInterval" step="10" value="100">
                            <div class="region-info">Bold contour spacing</div>
                        </div>
                        <div class="input-field">
                            <label>MGRS Grid (m)</label>
                            <input type="number" id="mgrsGridInterval" step="100" value="1000">
                            <div class="region-info">Grid line interval</div>
                        </div>
                    </div>
                </div>

                <!-- Print Settings -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 12px; color: #aaa; text-transform: uppercase;">Print Layout (inches)</label>
                    <div class="input-group">
                        <div class="input-field">
                            <label>Trim Width</label>
                            <input type="number" id="trimWidthIn" step="0.5" value="34.0">
                        </div>
                        <div class="input-field">
                            <label>Trim Height</label>
                            <input type="number" id="trimHeightIn" step="0.5" value="22.0">
                        </div>
                        <div class="input-field">
                            <label>Bleed</label>
                            <input type="number" id="bleedIn" step="0.0625" value="0.125">
                            <div class="region-info">Standard: 0.125 (1/8")</div>
                        </div>
                        <div class="input-field">
                            <label>Data Margin</label>
                            <input type="number" id="dataMarginIn" step="0.125" value="1.25">
                            <div class="region-info">Outside bleed for legend</div>
                        </div>
                    </div>
                </div>

                <!-- Play Margins -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 12px; color: #aaa; text-transform: uppercase;">Play Margins (inches from trim)</label>
                    <div class="input-group">
                        <div class="input-field">
                            <label>Top</label>
                            <input type="number" id="playMarginTop" step="0.125" value="0.0">
                        </div>
                        <div class="input-field">
                            <label>Bottom</label>
                            <input type="number" id="playMarginBottom" step="0.125" value="0.0">
                        </div>
                        <div class="input-field">
                            <label>Left</label>
                            <input type="number" id="playMarginLeft" step="0.125" value="0.0">
                        </div>
                        <div class="input-field">
                            <label>Right</label>
                            <input type="number" id="playMarginRight" step="0.125" value="0.0">
                        </div>
                    </div>
                </div>

                <!-- Elevation Settings -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 12px; color: #aaa; text-transform: uppercase;">Elevation (Game Map)</label>
                    <div class="input-group">
                        <div class="input-field">
                            <label>Band Interval (m)</label>
                            <input type="text" id="elevationBandInterval" value="auto">
                            <div class="region-info">"auto" for ~4 bands, or number (50, 100, 150...)</div>
                        </div>
                    </div>
                </div>

                <button class="generate-btn" onclick="saveSettings()" style="background-color: #2e7d32;">Save Settings</button>
                <div class="region-info" style="margin-top: 10px;">Settings are saved to map_defaults.json. Server restart may be needed.</div>
            </div>
        </div>

        <!-- Current Configuration (collapsible, expanded by default) -->
        <div class="panel">
            <h2 style="cursor: pointer;" onclick="toggleConfig()">
                Current Configuration <span id="configToggle" style="float: right; font-size: 12px;">‚ñº</span>
            </h2>
            <div class="config-display" id="configDisplay" style="display: block;">
                <!-- Populated by JS -->
            </div>
            <div class="command-wrapper" style="margin-top: 15px; display: none;" id="commandWrapper">
                <div class="command-output" id="commandOutput"></div>
                <button class="copy-btn" id="copyBtn" onclick="copyCommand()" style="display: none;">Copy</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // UI Helper Functions
        // ============================================

        function toggleInstructions() {
            const content = document.getElementById('instructionsContent');
            const toggle = document.getElementById('instructionsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function toggleConfig() {
            const content = document.getElementById('configDisplay');
            const toggle = document.getElementById('configToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
                updateConfigDisplay();
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function toggleSettings() {
            const content = document.getElementById('settingsContent');
            const toggle = document.getElementById('settingsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
                loadSettings();
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        async function loadSettings() {
            try {
                const response = await fetch('/api/defaults');
                if (!response.ok) throw new Error('Failed to load settings');
                const defaults = await response.json();

                // Grid settings
                document.getElementById('hexSizeM').value = defaults.grid?.hex_size_m ?? 250;
                document.getElementById('gridWidth').value = defaults.grid?.grid_width ?? 47;
                document.getElementById('gridHeight').value = defaults.grid?.grid_height ?? 26;

                // Contour settings
                document.getElementById('contourInterval').value = defaults.contours?.contour_interval_m ?? 20;
                document.getElementById('indexContourInterval').value = defaults.contours?.index_contour_interval_m ?? 100;
                document.getElementById('mgrsGridInterval').value = defaults.mgrs?.grid_interval_m ?? 1000;

                // Print settings
                document.getElementById('trimWidthIn').value = defaults.print?.trim_width_in ?? 34.0;
                document.getElementById('trimHeightIn').value = defaults.print?.trim_height_in ?? 22.0;
                document.getElementById('bleedIn').value = defaults.print?.bleed_in ?? 0.125;
                document.getElementById('dataMarginIn').value = defaults.print?.data_margin_in ?? 1.25;

                // Play margins
                document.getElementById('playMarginTop').value = defaults.play_margins?.top_in ?? 0.0;
                document.getElementById('playMarginBottom').value = defaults.play_margins?.bottom_in ?? 0.0;
                document.getElementById('playMarginLeft').value = defaults.play_margins?.left_in ?? 0.0;
                document.getElementById('playMarginRight').value = defaults.play_margins?.right_in ?? 0.0;

                // Elevation settings
                document.getElementById('elevationBandInterval').value = defaults.elevation?.band_interval ?? 'auto';
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }

        async function saveSettings() {
            const defaults = {
                grid: {
                    hex_size_m: parseFloat(document.getElementById('hexSizeM').value),
                    grid_width: parseInt(document.getElementById('gridWidth').value),
                    grid_height: parseInt(document.getElementById('gridHeight').value)
                },
                contours: {
                    contour_interval_m: parseInt(document.getElementById('contourInterval').value),
                    index_contour_interval_m: parseInt(document.getElementById('indexContourInterval').value)
                },
                print: {
                    trim_width_in: parseFloat(document.getElementById('trimWidthIn').value),
                    trim_height_in: parseFloat(document.getElementById('trimHeightIn').value),
                    bleed_in: parseFloat(document.getElementById('bleedIn').value),
                    data_margin_in: parseFloat(document.getElementById('dataMarginIn').value)
                },
                play_margins: {
                    top_in: parseFloat(document.getElementById('playMarginTop').value),
                    bottom_in: parseFloat(document.getElementById('playMarginBottom').value),
                    left_in: parseFloat(document.getElementById('playMarginLeft').value),
                    right_in: parseFloat(document.getElementById('playMarginRight').value)
                },
                mgrs: {
                    grid_interval_m: parseInt(document.getElementById('mgrsGridInterval').value)
                },
                elevation: {
                    band_interval: document.getElementById('elevationBandInterval').value.trim() || 'auto'
                }
            };

            try {
                const response = await fetch('/api/defaults', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(defaults)
                });

                if (!response.ok) throw new Error('Failed to save settings');
                const result = await response.json();
                alert(result.message || 'Settings saved successfully!');
            } catch (error) {
                console.error('Error saving settings:', error);
                alert('Error saving settings: ' + error.message);
            }
        }

        // ============================================
        // MGRS Calculation Functions
        // ============================================

        // UTM Zone letters for latitude bands
        const MGRS_BANDS = 'CDEFGHJKLMNPQRSTUVWXX';

        // 100km square column letters (repeats every 3 zones)
        const MGRS_COL_LETTERS = [
            'ABCDEFGH', // Zone 1, 4, 7, ...
            'JKLMNPQR', // Zone 2, 5, 8, ...
            'STUVWXYZ'  // Zone 3, 6, 9, ...
        ];

        // 100km square row letters (repeats every 2M northing)
        const MGRS_ROW_LETTERS_ODD = 'ABCDEFGHJKLMNPQRSTUV';  // Odd zones
        const MGRS_ROW_LETTERS_EVEN = 'FGHJKLMNPQRSTUVABCDE'; // Even zones

        function latLonToUTM(lat, lon) {
            // Simplified UTM conversion
            const zone = Math.floor((lon + 180) / 6) + 1;

            // WGS84 parameters
            const a = 6378137.0;
            const f = 1 / 298.257223563;
            const k0 = 0.9996;

            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;

            const lonOrigin = (zone - 1) * 6 - 180 + 3;
            const lonOriginRad = lonOrigin * Math.PI / 180;

            const e2 = 2 * f - f * f;
            const ep2 = e2 / (1 - e2);

            const N = a / Math.sqrt(1 - e2 * Math.sin(latRad) * Math.sin(latRad));
            const T = Math.tan(latRad) * Math.tan(latRad);
            const C = ep2 * Math.cos(latRad) * Math.cos(latRad);
            const A = Math.cos(latRad) * (lonRad - lonOriginRad);

            const M = a * ((1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256) * latRad
                - (3*e2/8 + 3*e2*e2/32 + 45*e2*e2*e2/1024) * Math.sin(2*latRad)
                + (15*e2*e2/256 + 45*e2*e2*e2/1024) * Math.sin(4*latRad)
                - (35*e2*e2*e2/3072) * Math.sin(6*latRad));

            const easting = k0 * N * (A + (1-T+C)*A*A*A/6
                + (5-18*T+T*T+72*C-58*ep2)*A*A*A*A*A/120) + 500000;

            let northing = k0 * (M + N * Math.tan(latRad) * (A*A/2
                + (5-T+9*C+4*C*C)*A*A*A*A/24
                + (61-58*T+T*T+600*C-330*ep2)*A*A*A*A*A*A/720));

            if (lat < 0) {
                northing += 10000000;
            }

            return { zone, easting, northing, hemisphere: lat >= 0 ? 'N' : 'S' };
        }

        function getLatitudeBand(lat) {
            if (lat < -80) return 'C';
            if (lat >= 84) return 'X';
            const idx = Math.floor((lat + 80) / 8);
            return MGRS_BANDS[idx];
        }

        function get100kmSquareId(zone, easting, northing, hemisphere) {
            // Column letter
            const setIndex = (zone - 1) % 3;
            const colLetters = MGRS_COL_LETTERS[setIndex];
            const col100km = Math.floor(easting / 100000);
            const colLetter = colLetters[(col100km - 1) % 8];

            // Row letter
            const rowLetters = (zone % 2 === 1) ? MGRS_ROW_LETTERS_ODD : MGRS_ROW_LETTERS_EVEN;
            const row100km = Math.floor(northing / 100000) % 20;
            const rowLetter = rowLetters[row100km];

            return colLetter + rowLetter;
        }

        function latLonToMGRS(lat, lon) {
            const utm = latLonToUTM(lat, lon);
            const band = getLatitudeBand(lat);
            const squareId = get100kmSquareId(utm.zone, utm.easting, utm.northing, utm.hemisphere);

            return {
                gzd: `${utm.zone}${band}`,
                square: squareId,
                full: `${utm.zone}${band} ${squareId}`,
                path: `${utm.zone}${band}/${squareId}`
            };
        }

        // Reverse conversion: UTM to Lat/Lon
        function utmToLatLon(zone, easting, northing, hemisphere) {
            const a = 6378137.0;
            const f = 1 / 298.257223563;
            const k0 = 0.9996;
            const e2 = 2 * f - f * f;
            const e1 = (1 - Math.sqrt(1 - e2)) / (1 + Math.sqrt(1 - e2));
            const ep2 = e2 / (1 - e2);

            const x = easting - 500000;
            let y = northing;
            if (hemisphere === 'S') {
                y -= 10000000;
            }

            const lonOriginDeg = (zone - 1) * 6 - 180 + 3;
            const lonOriginRad = lonOriginDeg * Math.PI / 180;
            const M = y / k0;
            const mu = M / (a * (1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256));

            const phi1 = mu + (3*e1/2 - 27*e1*e1*e1/32) * Math.sin(2*mu)
                + (21*e1*e1/16 - 55*e1*e1*e1*e1/32) * Math.sin(4*mu)
                + (151*e1*e1*e1/96) * Math.sin(6*mu);

            const N1 = a / Math.sqrt(1 - e2 * Math.sin(phi1) * Math.sin(phi1));
            const T1 = Math.tan(phi1) * Math.tan(phi1);
            const C1 = ep2 * Math.cos(phi1) * Math.cos(phi1);
            const R1 = a * (1 - e2) / Math.pow(1 - e2 * Math.sin(phi1) * Math.sin(phi1), 1.5);
            const D = x / (N1 * k0);

            const lat = phi1 - (N1 * Math.tan(phi1) / R1) * (D*D/2
                - (5 + 3*T1 + 10*C1 - 4*C1*C1 - 9*ep2) * D*D*D*D/24
                + (61 + 90*T1 + 298*C1 + 45*T1*T1 - 252*ep2 - 3*C1*C1) * D*D*D*D*D*D/720);

            const lon = lonOriginRad + (D - (1 + 2*T1 + C1) * D*D*D/6
                + (5 - 2*C1 + 28*T1 - 3*C1*C1 + 8*ep2 + 24*T1*T1) * D*D*D*D*D/120) / Math.cos(phi1);

            return {
                lat: lat * 180 / Math.PI,
                lon: lon * 180 / Math.PI
            };
        }

        // Parse MGRS and convert to Lat/Lon
        function mgrsToLatLon(mgrsStr) {
            // Remove spaces and convert to uppercase
            const mgrs = mgrsStr.replace(/\s+/g, '').toUpperCase();

            // Parse MGRS: zone(1-2 digits) + band(1 letter) + square(2 letters) + digits(even count)
            const match = mgrs.match(/^(\d{1,2})([C-X])([A-HJ-NP-Z]{2})(\d*)$/);
            if (!match) {
                return null;
            }

            const zone = parseInt(match[1]);
            const band = match[2];
            const squareId = match[3];
            const digits = match[4];

            // Digits must be even (equal easting/northing)
            if (digits.length % 2 !== 0) {
                return null;
            }

            // Parse easting and northing from digits
            const precision = digits.length / 2;
            let easting100k, northing100k;

            if (precision === 0) {
                // Center of 100km square
                easting100k = 50000;
                northing100k = 50000;
            } else {
                const eastDigits = digits.slice(0, precision);
                const northDigits = digits.slice(precision);
                // Scale to meters (pad to 5 digits)
                easting100k = parseInt(eastDigits) * Math.pow(10, 5 - precision);
                northing100k = parseInt(northDigits) * Math.pow(10, 5 - precision);
            }

            // Get column letter index
            const setIndex = (zone - 1) % 3;
            const colLetters = MGRS_COL_LETTERS[setIndex];
            const colIndex = colLetters.indexOf(squareId[0]);
            if (colIndex === -1) return null;

            // Get row letter index
            const rowLetters = (zone % 2 === 1) ? MGRS_ROW_LETTERS_ODD : MGRS_ROW_LETTERS_EVEN;
            const rowIndex = rowLetters.indexOf(squareId[1]);
            if (rowIndex === -1) return null;

            // Calculate UTM easting
            const easting = (colIndex + 1) * 100000 + easting100k;

            // Calculate UTM northing - need to determine the correct 2M northing cycle
            // based on the latitude band
            const bandIndex = MGRS_BANDS.indexOf(band);
            if (bandIndex === -1) return null;

            // Approximate latitude for this band
            const bandLat = -80 + bandIndex * 8 + 4; // center of band
            const hemisphere = bandLat >= 0 ? 'N' : 'S';

            // Calculate base northing from row index
            let baseNorthing = rowIndex * 100000;

            // Determine which 2,000,000m cycle we're in based on band
            // Each latitude band spans roughly 888km of northing
            // We need to find the right multiple of 2,000,000
            const bandMinNorthing = (bandIndex * 8 + (-80)) >= 0 ?
                ((bandIndex * 8 + (-80)) / 90 * 10000000) :
                10000000 + ((bandIndex * 8 + (-80)) / 90 * 10000000);

            // Find the 2M cycle that contains this band
            const cycle = Math.floor(bandMinNorthing / 2000000);
            let northing = cycle * 2000000 + baseNorthing + northing100k;

            // Adjust if the row letter cycle wrapped
            // The row letters repeat every 2,000,000m of northing
            // We need to check if our calculated northing is in the right band
            let result = utmToLatLon(zone, easting, northing, hemisphere);

            // Verify the result is in the right latitude band
            const resultBand = getLatitudeBand(result.lat);
            if (resultBand !== band) {
                // Try next or previous 2M cycle
                const altNorthing = northing + 2000000;
                const altResult = utmToLatLon(zone, easting, altNorthing, hemisphere);
                if (getLatitudeBand(altResult.lat) === band) {
                    return altResult;
                }

                const altNorthing2 = northing - 2000000;
                const altResult2 = utmToLatLon(zone, easting, altNorthing2, hemisphere);
                if (getLatitudeBand(altResult2.lat) === band) {
                    return altResult2;
                }
            }

            return result;
        }

        // Parse DMS (Degrees Minutes Seconds) format
        function parseDMS(dmsStr) {
            // Various DMS formats:
            // 24¬∞08'51.8"N 120¬∞40'25.0"E
            // 24 08 51.8 N 120 40 25.0 E
            // 24¬∞ 8' 51.8" N, 120¬∞ 40' 25.0" E
            // N24¬∞08'51.8" E120¬∞40'25.0"

            const str = dmsStr.trim();

            // Pattern for one coordinate: degrees, minutes, seconds, direction
            const dmsPattern = /([NSEW])?[:\s]*(-?\d+)[¬∞\s]+(\d+)['\s]+(\d+\.?\d*)["\s]*([NSEW])?/gi;
            const matches = [...str.matchAll(dmsPattern)];

            if (matches.length !== 2) {
                return null;
            }

            const coords = matches.map(m => {
                const dir1 = m[1] ? m[1].toUpperCase() : null;
                const dir2 = m[5] ? m[5].toUpperCase() : null;
                const dir = dir1 || dir2;

                let degrees = parseFloat(m[2]);
                const minutes = parseFloat(m[3]);
                const seconds = parseFloat(m[4]);

                let decimal = Math.abs(degrees) + minutes / 60 + seconds / 3600;
                if (degrees < 0 || dir === 'S' || dir === 'W') {
                    decimal = -decimal;
                }

                return { value: decimal, dir: dir };
            });

            // Determine which is lat and which is lon
            let lat, lon;
            if (coords[0].dir === 'N' || coords[0].dir === 'S') {
                lat = coords[0].value;
                lon = coords[1].value;
            } else if (coords[1].dir === 'N' || coords[1].dir === 'S') {
                lat = coords[1].value;
                lon = coords[0].value;
            } else {
                // Assume lat, lon order if no clear direction
                lat = coords[0].value;
                lon = coords[1].value;
            }

            if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                return { lat, lon };
            }
            return null;
        }

        // ============================================
        // Map Bounds Calculation
        // ============================================

        // Map parameters (should match tactical_map.py)
        const GRID_WIDTH = 47;
        const GRID_HEIGHT = 26;

        // Get hex size from input field (dynamic, not hardcoded)
        function getHexSizeM() {
            return parseFloat(document.getElementById('hexSizeM').value) || 250;
        }

        function calculateMapBounds(centerLat, centerLon, rotationDeg) {
            // Calculate map dimensions using dynamic hex size
            const hexSizeM = getHexSizeM();
            const size = hexSizeM / Math.sqrt(3);
            const colSpacing = 1.5 * size;
            const rowSpacing = hexSizeM;

            const widthM = (GRID_WIDTH - 1) * colSpacing + 2 * size;
            const heightM = GRID_HEIGHT * rowSpacing;

            // When rotated, the bounding box needs to be larger
            let effectiveRadius;
            if (rotationDeg !== 0) {
                // Diagonal of the map
                effectiveRadius = Math.sqrt(widthM * widthM + heightM * heightM) / 2 + 500;
            } else {
                effectiveRadius = Math.max(widthM, heightM) / 2 + 500;
            }

            // Convert to degrees (approximate)
            const latDelta = effectiveRadius / 111000;
            const lonDelta = effectiveRadius / (111000 * Math.cos(centerLat * Math.PI / 180));

            return {
                minLat: centerLat - latDelta,
                maxLat: centerLat + latDelta,
                minLon: centerLon - lonDelta,
                maxLon: centerLon + lonDelta,
                widthKm: widthM / 1000,
                heightKm: heightM / 1000
            };
        }

        function getRequiredMGRSSquares(centerLat, centerLon, rotationDeg) {
            const bounds = calculateMapBounds(centerLat, centerLon, rotationDeg);
            const squares = new Map(); // Use Map to deduplicate

            // Check corners and edges
            const checkPoints = [
                { lat: centerLat, lon: centerLon, isPrimary: true },
                { lat: bounds.minLat, lon: bounds.minLon },
                { lat: bounds.minLat, lon: bounds.maxLon },
                { lat: bounds.maxLat, lon: bounds.minLon },
                { lat: bounds.maxLat, lon: bounds.maxLon },
                { lat: bounds.minLat, lon: centerLon },
                { lat: bounds.maxLat, lon: centerLon },
                { lat: centerLat, lon: bounds.minLon },
                { lat: centerLat, lon: bounds.maxLon },
            ];

            for (const point of checkPoints) {
                try {
                    const mgrs = latLonToMGRS(point.lat, point.lon);
                    const key = mgrs.path;
                    if (!squares.has(key)) {
                        squares.set(key, {
                            ...mgrs,
                            isPrimary: point.isPrimary || false
                        });
                    } else if (point.isPrimary) {
                        squares.get(key).isPrimary = true;
                    }
                } catch (e) {
                    console.warn('MGRS calculation failed for point:', point, e);
                }
            }

            return Array.from(squares.values());
        }

        // ============================================
        // Configuration State
        // ============================================

        const state = {
            centerLat: null,  // User must enter coordinates
            centerLon: null,
            bearingAtTop: 0,    // What compass bearing points to top of map (0=North, 90=East, etc.)
            region: '', // Auto-detect by default
            mapName: '',  // User should provide a name
            shiftNorth: 0,      // Geographic shift tracking (for display)
            shiftEast: 0,
            mapShiftUp: 0,      // Map-relative shift tracking (for notes)
            mapShiftRight: 0,
            requiredSquares: [],
            availableRegions: [],
            // Multi-map settings
            multiMap: {
                enabled: false,
                count: 1,           // 1, 2, 3, or 4 maps
                orientation: 'short_edge'  // 'short_edge' or 'long_edge' (for 2-3 maps)
            }
        };

        // Helper to convert bearing to direction name
        function bearingToDirection(bearing) {
            const directions = ['North', 'NNE', 'NE', 'ENE', 'East', 'ESE', 'SE', 'SSE',
                               'South', 'SSW', 'SW', 'WSW', 'West', 'WNW', 'NW', 'NNW'];
            const index = Math.round(((bearing % 360) + 360) % 360 / 22.5) % 16;
            return directions[index];
        }

        // Convert bearingAtTop to internal rotation_deg (for backend)
        function bearingToRotation(bearing) {
            return -bearing;  // Simple: if 60¬∞ at top, rotate map -60¬∞
        }

        // Known available regions - populated dynamically from downloaded PBF files
        // Will be loaded from server or can be expanded as data is downloaded
        const KNOWN_REGIONS = [
            // Regions are auto-discovered from data/geofabrik/*.osm.pbf files
        ];

        // Approximate meters per degree
        const METERS_PER_DEG_LAT = 110574;
        const METERS_PER_DEG_LON = 101320;

        // ============================================
        // UI Functions
        // ============================================

        function updateMGRSDisplay() {
            const container = document.getElementById('mgrsSquares');

            // Check for valid coordinates before calculating MGRS
            if (state.centerLat === null || state.centerLon === null ||
                isNaN(state.centerLat) || isNaN(state.centerLon)) {
                container.innerHTML = '<div style="color: #888; font-style: italic;">Enter coordinates to see required MGRS squares</div>';
                state.requiredSquares = [];
                state.autoRegion = '';
                return;
            }

            state.requiredSquares = getRequiredMGRSSquares(
                state.centerLat,
                state.centerLon,
                bearingToRotation(state.bearingAtTop)
            );

            // Initial render without status (will update async)
            renderMGRSSquares(container, {});

            // Update region in state (use primary square)
            const primarySquare = state.requiredSquares.find(sq => sq.isPrimary);
            if (primarySquare && !state.region) {
                // Only auto-set if not manually selected
                state.autoRegion = primarySquare.path;
            }

            // Check data status for each square (if server is available)
            if (serverAvailable) {
                checkDataStatus();
            }
        }

        function renderMGRSSquares(container, dataStatus) {
            let html = '';

            for (const sq of state.requiredSquares) {
                const primaryClass = sq.isPrimary ? 'primary' : '';
                const label = sq.isPrimary ? '(center)' : '';

                // Determine status class and icon
                let statusClass = '';
                let icon = '';
                if (dataStatus[sq.path] === true) {
                    statusClass = 'available';
                    icon = '<span class="icon">‚úì</span>';
                } else if (dataStatus[sq.path] === false) {
                    statusClass = 'missing';
                    icon = '<span class="icon">‚ö†</span>';
                }

                html += `
                    <div class="mgrs-square ${statusClass} ${primaryClass}">
                        ${icon}<span>${sq.full}</span>
                        <span class="label">${label}</span>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        async function checkDataStatus() {
            const container = document.getElementById('mgrsSquares');
            const dataStatus = {};

            // Check each required square
            for (const sq of state.requiredSquares) {
                try {
                    const response = await fetch('/api/check-data', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ region: sq.path })
                    });
                    const data = await response.json();
                    dataStatus[sq.path] = data.exists === true;
                } catch (e) {
                    // Server not available or error - skip status
                }
            }

            // Re-render with status
            renderMGRSSquares(container, dataStatus);
        }

        function updateDisplay() {
            updateMGRSDisplay();

            const display = document.getElementById('configDisplay');
            const effectiveRegion = state.region || state.autoRegion || 'auto-detect';

            // Check for valid coordinates
            const hasCoords = state.centerLat !== null && state.centerLon !== null &&
                              !isNaN(state.centerLat) && !isNaN(state.centerLon);

            // Show map-relative shift info
            const shiftInfo = (state.mapShiftUp !== 0 || state.mapShiftRight !== 0)
                ? `\n<span class="label">Position Adjusted:</span> <span class="value">${formatShift(state.mapShiftUp, '‚Üë', '‚Üì')}, ${formatShift(state.mapShiftRight, '‚Üí', '‚Üê')}</span>`
                : '';

            const bearingDisplay = state.bearingAtTop === 0
                ? '0¬∞ (North up)'
                : `${state.bearingAtTop}¬∞ (${bearingToDirection(state.bearingAtTop)} at top)`;

            const centerDisplay = hasCoords
                ? `${state.centerLat.toFixed(6)}&deg;N, ${state.centerLon.toFixed(6)}&deg;E`
                : '<span style="color: #888; font-style: italic;">Not set - enter coordinates above</span>';

            // Multi-map display
            const multiMapDisplay = state.multiMap.enabled
                ? `${state.multiMap.count} maps (${state.multiMap.orientation.replace('_', ' ')})`
                : 'Single map';

            display.innerHTML = `
<span class="label">Center:</span> <span class="value coords">${centerDisplay}</span>
<span class="label">Bearing at Top:</span> <span class="value">${bearingDisplay}</span>
<span class="label">Layout:</span> <span class="value">${multiMapDisplay}</span>
<span class="label">Region:</span> <span class="value">${effectiveRegion}</span>
<span class="label">Map Name:</span> <span class="value">${state.mapName || '<span style="color: #888;">Not set</span>'}</span>${shiftInfo}
            `.trim();
        }

        function formatShift(meters, posDir, negDir) {
            if (meters === 0) return '0m';
            const dir = meters > 0 ? posDir : negDir;
            const abs = Math.abs(meters);
            if (abs >= 1000) {
                return `${(abs/1000).toFixed(1)}km ${dir}`;
            }
            return `${abs}m ${dir}`;
        }

        function getShiftDistance() {
            const selected = document.querySelector('input[name="shiftDist"]:checked');
            return selected ? parseInt(selected.value) : 1000;
        }

        function shift(direction) {
            // Check for valid coordinates before shifting
            if (state.centerLat === null || state.centerLon === null ||
                isNaN(state.centerLat) || isNaN(state.centerLon)) {
                showStatus('Enter coordinates before adjusting position', 'warning');
                return;
            }

            const distance = getShiftDistance();

            // Calculate bearing based on map-relative direction
            // bearingAtTop = the compass bearing that points to top of map
            // So "up" on the map = move toward bearingAtTop
            let bearing;
            switch(direction) {
                case 'up':
                    bearing = state.bearingAtTop;  // Up = toward bearing at top
                    break;
                case 'down':
                    bearing = state.bearingAtTop + 180;  // Down = opposite
                    break;
                case 'right':
                    bearing = state.bearingAtTop + 90;  // Right = 90¬∞ clockwise from top
                    break;
                case 'left':
                    bearing = state.bearingAtTop + 270;  // Left = 90¬∞ counter-clockwise from top
                    break;
                default:
                    return;
            }

            // Normalize bearing to 0-360
            bearing = ((bearing % 360) + 360) % 360;

            // Convert bearing to radians
            const bearingRad = bearing * Math.PI / 180;

            // Calculate lat/lon deltas
            // North component = distance * cos(bearing)
            // East component = distance * sin(bearing)
            const deltaLat = distance * Math.cos(bearingRad) / METERS_PER_DEG_LAT;
            const deltaLon = distance * Math.sin(bearingRad) / METERS_PER_DEG_LON;

            // Update state - geographic shift
            state.shiftNorth += distance * Math.cos(bearingRad);
            state.shiftEast += distance * Math.sin(bearingRad);
            state.centerLat += deltaLat;
            state.centerLon += deltaLon;

            // Track map-relative shift for notes
            switch(direction) {
                case 'up': state.mapShiftUp += distance; break;
                case 'down': state.mapShiftUp -= distance; break;
                case 'right': state.mapShiftRight += distance; break;
                case 'left': state.mapShiftRight -= distance; break;
            }

            document.getElementById('centerLat').value = state.centerLat.toFixed(6);
            document.getElementById('centerLon').value = state.centerLon.toFixed(6);

            updateDisplay();
            updatePreviewBoundary();
        }

        function saveConfig() {
            // Check for valid coordinates
            if (state.centerLat === null || state.centerLon === null ||
                isNaN(state.centerLat) || isNaN(state.centerLon)) {
                showStatus('Please enter valid coordinates first.', 'warning');
                return;
            }

            const effectiveRegion = state.region || state.autoRegion;

            if (!effectiveRegion) {
                showStatus('Cannot determine region. Please enter valid coordinates or select a region.', 'warning');
                return;
            }

            const config = {
                name: state.mapName,
                center_lat: state.centerLat,
                center_lon: state.centerLon,
                region: effectiveRegion,
                rotation_deg: bearingToRotation(state.bearingAtTop)
            };

            // Add multi-map settings if enabled
            if (state.multiMap.enabled) {
                config.multi_map = {
                    enabled: true,
                    count: state.multiMap.count,
                    orientation: state.multiMap.orientation,
                    overlap_hexes: 1  // Default: 1 shared column/row of hexes
                };
            }

            // Add adjustment notes if any map-relative shifts were made
            if (state.mapShiftUp !== 0 || state.mapShiftRight !== 0) {
                const parts = [];
                if (state.mapShiftUp !== 0) {
                    const dir = state.mapShiftUp > 0 ? 'up' : 'down';
                    parts.push(`${Math.abs(state.mapShiftUp)}m ${dir}`);
                }
                if (state.mapShiftRight !== 0) {
                    const dir = state.mapShiftRight > 0 ? 'right' : 'left';
                    parts.push(`${Math.abs(state.mapShiftRight)}m ${dir}`);
                }
                config._adjustment_notes = `Shifted ${parts.join(', ')} (map-relative)`;
            }

            const jsonStr = JSON.stringify(config, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('Config saved! Move map_config.json to your project folder and run: python tactical_map.py', 'success');
        }

        function generateCommand() {
            const effectiveRegion = state.region || state.autoRegion;

            const pythonConfig = `# Configuration for tactical map generation
# Generated by map_config.html

config = MapConfig(
    name="${state.mapName}",
    center_lat=${state.centerLat.toFixed(6)},
    center_lon=${state.centerLon.toFixed(6)},
    region="${effectiveRegion}",
    rotation_deg=${bearingToRotation(state.bearingAtTop)},  # ${state.bearingAtTop}¬∞ at top
)

# Required MGRS squares: ${state.requiredSquares.map(sq => sq.full).join(', ')}
`;

            const output = document.getElementById('commandOutput');
            output.textContent = pythonConfig;
            output.classList.add('visible');
            document.getElementById('copyBtn').style.display = 'block';

            showStatus('Configuration generated! Copy and paste into tactical_map.py main() function.', 'info');
        }

        function copyCommand() {
            const output = document.getElementById('commandOutput');
            navigator.clipboard.writeText(output.textContent).then(() => {
                showStatus('Copied to clipboard!', 'success');
            });
        }

        function resetToDefaults() {
            state.centerLat = null;
            state.centerLon = null;
            state.bearingAtTop = 0;
            state.region = '';
            state.autoRegion = '';
            state.mapName = '';
            state.shiftNorth = 0;
            state.shiftEast = 0;
            state.mapShiftUp = 0;
            state.mapShiftRight = 0;
            state.multiMap = {
                enabled: false,
                count: 1,
                orientation: 'short_edge'
            };

            document.getElementById('coordPaste').value = '';
            document.getElementById('centerLat').value = '';
            document.getElementById('centerLon').value = '';
            document.getElementById('rotationSlider').value = state.bearingAtTop;
            document.getElementById('rotationValue').textContent = state.bearingAtTop;
            document.getElementById('rotationDirection').textContent = '(North)';
            document.getElementById('mapName').value = state.mapName;

            // Reset multi-map layout selection
            document.querySelectorAll('.layout-option').forEach(o => o.classList.remove('selected'));
            document.querySelector('.layout-option[data-count="1"]').classList.add('selected');
            document.querySelector('input[name="mapLayout"][value="single"]').checked = true;

            document.getElementById('commandOutput').classList.remove('visible');
            document.getElementById('copyBtn').style.display = 'none';

            updateDisplay();
            updatePreviewBoundary();
            showStatus('Reset to defaults', 'info');
        }

        function showStatus(message, type) {
            const status = document.getElementById('statusMsg');
            status.textContent = message;
            status.className = 'status ' + type;

            setTimeout(() => {
                status.className = 'status';
            }, 5000);
        }

        // ============================================
        // Server Integration
        // ============================================

        let serverAvailable = false;
        let eventSource = null;

        function checkServer() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    serverAvailable = true;
                    document.getElementById('serverStatus').innerHTML =
                        '<span style="color: #10b981;">Server connected</span> - Click "Generate Map" to create your map';
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('stopServerBtn').style.display = 'inline-block';
                    // Fetch and display version
                    fetch('/api/version')
                        .then(r => r.json())
                        .then(v => {
                            document.getElementById('versionLabel').textContent = `Rendering Engine ${v.version}`;
                        })
                        .catch(() => {});
                })
                .catch(() => {
                    serverAvailable = false;
                    document.getElementById('serverStatus').innerHTML =
                        'To generate maps directly, run: <code style="background: #0d1b2a; padding: 2px 6px; border-radius: 3px;">python map_server.py</code>';
                    document.getElementById('generateBtn').disabled = true;
                    document.getElementById('stopServerBtn').style.display = 'none';
                    document.getElementById('versionLabel').textContent = '';
                });
        }

        function stopServer() {
            if (!confirm('Stop the map generator server?')) {
                return;
            }

            fetch('/api/shutdown', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    showStatus('Server stopped. Close this tab or restart with: python map_server.py', 'info');
                    document.getElementById('serverStatus').innerHTML =
                        '<span style="color: #ef4444;">Server stopped</span> - Restart with: <code style="background: #0d1b2a; padding: 2px 6px; border-radius: 3px;">python map_server.py</code>';
                    document.getElementById('generateBtn').disabled = true;
                    document.getElementById('stopServerBtn').style.display = 'none';
                    serverAvailable = false;
                })
                .catch(error => {
                    // Server may have already stopped
                    showStatus('Server stopped', 'info');
                    serverAvailable = false;
                });
        }

        function generateMap() {
            if (!serverAvailable) {
                showStatus('Server not running. Start with: python map_server.py', 'warning');
                return;
            }

            // Check for valid coordinates
            if (state.centerLat === null || state.centerLon === null ||
                isNaN(state.centerLat) || isNaN(state.centerLon)) {
                showStatus('Please enter valid coordinates first.', 'warning');
                return;
            }

            const effectiveRegion = state.region || state.autoRegion;
            if (!effectiveRegion) {
                showStatus('Cannot determine region. Please enter valid coordinates.', 'warning');
                return;
            }

            const config = {
                name: state.mapName,
                center_lat: state.centerLat,
                center_lon: state.centerLon,
                region: effectiveRegion,
                rotation_deg: bearingToRotation(state.bearingAtTop),
                hex_size_m: getHexSizeM()
            };

            // Add multi-map settings if enabled
            if (state.multiMap.enabled) {
                config.multi_map = {
                    enabled: true,
                    count: state.multiMap.count,
                    orientation: state.multiMap.orientation,
                    overlap_hexes: 1
                };
            }

            // Add elevation band interval (read from settings input)
            const elevationInput = document.getElementById('elevationBandInterval').value.trim();
            config.elevation_band_interval = elevationInput || 'auto';

            // Add contour intervals
            config.contour_interval = parseInt(document.getElementById('contourInterval').value) || 20;
            config.index_contour_interval = parseInt(document.getElementById('indexContourInterval').value) || 100;

            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            const progressOutput = document.getElementById('progressOutput');
            progressContainer.style.display = 'block';
            progressOutput.innerHTML = '';

            // Disable generate button
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            btn.textContent = 'Generating...';

            // Start generation
            fetch('/api/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }

                // Connect to progress stream
                if (eventSource) {
                    eventSource.close();
                }

                eventSource = new EventSource('/api/progress');

                eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'output') {
                        appendProgress(data.message);
                    } else if (data.type === 'complete') {
                        appendProgress('\n‚úì ' + data.message, 'success');
                        showStatus('Map generation complete!', 'success');
                        finishGeneration();
                    } else if (data.type === 'error') {
                        appendProgress('\n‚úó Error: ' + data.message, 'error');
                        showStatus('Generation failed: ' + data.message, 'warning');
                        finishGeneration();
                    }
                };

                eventSource.onerror = () => {
                    eventSource.close();
                    finishGeneration();
                };
            })
            .catch(error => {
                appendProgress('Error: ' + error.message, 'error');
                showStatus('Failed to start generation: ' + error.message, 'warning');
                finishGeneration();
            });
        }

        function appendProgress(text, type = 'normal') {
            const progressOutput = document.getElementById('progressOutput');
            const span = document.createElement('span');
            span.textContent = text + '\n';

            if (type === 'success') {
                span.style.color = '#10b981';
            } else if (type === 'error') {
                span.style.color = '#ef4444';
            }

            progressOutput.appendChild(span);
            progressOutput.scrollTop = progressOutput.scrollHeight;
        }

        function finishGeneration() {
            const btn = document.getElementById('generateBtn');
            btn.disabled = false;
            btn.textContent = 'Generate Map';

            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        }

        function clearProgress() {
            document.getElementById('progressOutput').innerHTML = '';
            document.getElementById('progressContainer').style.display = 'none';
        }

        // ============================================
        // Initialize
        // ============================================

        document.addEventListener('DOMContentLoaded', () => {
            // Parse coordinates - supports multiple formats
            document.getElementById('coordPaste').addEventListener('input', (e) => {
                const value = e.target.value.trim();
                if (!value) return;

                let lat, lon;
                let format = '';

                // 1. Try MGRS format (e.g., "51PTT1234567890" or "51P TT 12345 67890")
                const mgrsPattern = /^\d{1,2}[C-X]\s*[A-HJ-NP-Z]{2}\s*\d*$/i;
                if (mgrsPattern.test(value.replace(/\s+/g, ''))) {
                    const result = mgrsToLatLon(value);
                    if (result) {
                        lat = result.lat;
                        lon = result.lon;
                        format = 'MGRS';
                    }
                }

                // 2. Try DMS format (e.g., "24¬∞08'51.8"N 120¬∞40'25.0"E")
                if (!format && (value.includes('¬∞') || value.includes("'") || value.includes('"') || /[NSEW]/i.test(value))) {
                    const result = parseDMS(value);
                    if (result) {
                        lat = result.lat;
                        lon = result.lon;
                        format = 'DMS';
                    }
                }

                // 3. Try decimal degrees (e.g., "24.1477, 120.6736" or "24.1477 120.6736")
                if (!format) {
                    const decimalPatterns = [
                        /^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/,
                        /^(-?\d+\.?\d*)\s+(-?\d+\.?\d*)$/,
                    ];
                    for (const pattern of decimalPatterns) {
                        const match = value.match(pattern);
                        if (match) {
                            lat = parseFloat(match[1]);
                            lon = parseFloat(match[2]);
                            if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                                format = 'Decimal';
                            }
                            break;
                        }
                    }
                }

                // Apply parsed coordinates
                if (format && lat !== undefined && lon !== undefined) {
                    state.centerLat = lat;
                    state.centerLon = lon;
                    state.shiftNorth = 0;
                    state.shiftEast = 0;
                    state.mapShiftUp = 0;
                    state.mapShiftRight = 0;
                    state.region = ''; // Reset to auto-detect

                    document.getElementById('centerLat').value = lat.toFixed(6);
                    document.getElementById('centerLon').value = lon.toFixed(6);

                    updateDisplay();
                    updatePreviewBoundary();
                    showStatus(`${format} coordinates parsed: ${lat.toFixed(6)}, ${lon.toFixed(6)}`, 'success');
                }
            });

            // Coordinate inputs - reset shifts when manually changing coordinates
            document.getElementById('centerLat').addEventListener('input', (e) => {
                state.centerLat = parseFloat(e.target.value) || 0;
                state.shiftNorth = 0;
                state.shiftEast = 0;
                state.mapShiftUp = 0;
                state.mapShiftRight = 0;
                updateDisplay();
                updatePreviewBoundary();
            });

            document.getElementById('centerLon').addEventListener('input', (e) => {
                state.centerLon = parseFloat(e.target.value) || 0;
                state.shiftNorth = 0;
                state.shiftEast = 0;
                state.mapShiftUp = 0;
                state.mapShiftRight = 0;
                updateDisplay();
                updatePreviewBoundary();
            });

            // Bearing at top slider
            document.getElementById('rotationSlider').addEventListener('input', (e) => {
                state.bearingAtTop = parseInt(e.target.value);
                document.getElementById('rotationValue').textContent = state.bearingAtTop;
                document.getElementById('rotationDirection').textContent = `(${bearingToDirection(state.bearingAtTop)})`;
                updateDisplay();
            });

            // Map name
            document.getElementById('mapName').addEventListener('input', (e) => {
                state.mapName = e.target.value || 'untitled';
                updateDisplay();
            });

            // Multi-map layout selection
            document.querySelectorAll('.layout-option').forEach(option => {
                option.addEventListener('click', () => {
                    // Update selected state
                    document.querySelectorAll('.layout-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                    option.querySelector('input').checked = true;

                    // Update state
                    const count = parseInt(option.dataset.count);
                    const orientation = option.dataset.orientation;

                    state.multiMap.enabled = count > 1;
                    state.multiMap.count = count;
                    state.multiMap.orientation = orientation;

                    updateDisplay();
                    updatePreviewBoundary();
                });
            });

            updateDisplay();

            // Check if server is running
            checkServer();

            // Initialize preview map
            initPreviewMap();
        });

        // ============================================
        // Preview Map Functions
        // ============================================

        let previewMap = null;
        let boundaryPolygons = [];  // Array for multi-map support
        let centerMarker = null;
        let orientationArrow = null;
        let sheetLabels = [];  // Array of sheet label markers (A, B, C, D)

        function initPreviewMap() {
            // Initialize Leaflet map with a default view
            previewMap = L.map('previewMap', {
                center: [35, 135],  // Default to Japan area
                zoom: 8,
                zoomControl: true
            });

            // Add OpenTopoMap tiles (same source as reference tiles)
            L.tileLayer('https://tile.opentopomap.org/{z}/{x}/{y}.png', {
                maxZoom: 17,
                attribution: '¬© OpenTopoMap contributors'
            }).addTo(previewMap);

            // Add click handler for recentering
            previewMap.on('click', onMapClick);

            // Initial boundary update if we have coordinates
            updatePreviewBoundary();
        }

        function onMapClick(e) {
            // Update center coordinates
            state.centerLat = e.latlng.lat;
            state.centerLon = e.latlng.lng;
            state.shiftNorth = 0;
            state.shiftEast = 0;
            state.mapShiftUp = 0;
            state.mapShiftRight = 0;
            state.region = ''; // Reset to auto-detect

            // Update form fields
            document.getElementById('centerLat').value = state.centerLat.toFixed(6);
            document.getElementById('centerLon').value = state.centerLon.toFixed(6);

            // Update displays
            updateDisplay();
            updatePreviewBoundary();

            showStatus(`Center moved to ${state.centerLat.toFixed(6)}, ${state.centerLon.toFixed(6)}`, 'info');
        }

        function updatePreviewBoundary() {
            if (!previewMap) return;

            // Check for valid coordinates
            if (state.centerLat === null || state.centerLon === null ||
                isNaN(state.centerLat) || isNaN(state.centerLon)) {
                // Remove existing boundaries
                boundaryPolygons.forEach(p => previewMap.removeLayer(p));
                boundaryPolygons = [];
                sheetLabels.forEach(l => previewMap.removeLayer(l));
                sheetLabels = [];
                if (centerMarker) {
                    previewMap.removeLayer(centerMarker);
                    centerMarker = null;
                }
                if (orientationArrow) {
                    previewMap.removeLayer(orientationArrow);
                    orientationArrow = null;
                }
                document.getElementById('statCoverage').textContent = '--';
                document.getElementById('statRotation').textContent = '--';
                return;
            }

            // Calculate single map dimensions in meters using dynamic hex size
            const hexSizeM = getHexSizeM();
            const size = hexSizeM / Math.sqrt(3);
            const colSpacing = 1.5 * size;
            const rowSpacing = hexSizeM;
            const widthM = (GRID_WIDTH - 1) * colSpacing + 2 * size;
            const heightM = GRID_HEIGHT * rowSpacing + rowSpacing / 2;

            // Calculate sheet centers for multi-map
            const sheetCenters = calculateSheetCenters(
                state.centerLat,
                state.centerLon,
                state.bearingAtTop,
                state.multiMap.count,
                state.multiMap.orientation,
                widthM,
                heightM,
                1  // overlap_hexes
            );

            // Remove existing boundaries and labels
            boundaryPolygons.forEach(p => previewMap.removeLayer(p));
            boundaryPolygons = [];
            sheetLabels.forEach(l => previewMap.removeLayer(l));
            sheetLabels = [];
            if (orientationArrow) {
                previewMap.removeLayer(orientationArrow);
                orientationArrow = null;
            }

            // Half dimensions for corner calculation
            const halfWidth = widthM / 2;
            const halfHeight = heightM / 2;

            // Corner offsets in meters (relative to sheet center, unrotated)
            const sheetCorners = [
                { dx: -halfWidth, dy: halfHeight },   // Top-left
                { dx: halfWidth, dy: halfHeight },    // Top-right
                { dx: halfWidth, dy: -halfHeight },   // Bottom-right
                { dx: -halfWidth, dy: -halfHeight }   // Bottom-left
            ];

            // Rotation angle (for rotating around cluster center)
            const rotationRad = -state.bearingAtTop * Math.PI / 180;
            const cosR = Math.cos(rotationRad);
            const sinR = Math.sin(rotationRad);

            // Get unrotated sheet positions relative to cluster center
            const overlapHexes = state.multiMap.overlapHexes || 1;
            const unrotatedPositions = getUnrotatedSheetPositions(
                state.multiMap.count,
                state.multiMap.orientation,
                widthM, heightM,
                overlapHexes
            );

            // Create boundary polygon for each sheet
            let allBounds = null;
            sheetCenters.forEach((sheet, index) => {
                // Get the unrotated position for this sheet
                const unrotatedPos = unrotatedPositions[index] || { dx: 0, dy: 0 };

                // Calculate corners relative to cluster center, then rotate around cluster center
                const cornerLatLngs = sheetCorners.map(c => {
                    // Corner position relative to cluster center (unrotated)
                    const cornerDx = unrotatedPos.dx + c.dx;
                    const cornerDy = unrotatedPos.dy + c.dy;

                    // Rotate around cluster center
                    const rotatedDx = cornerDx * cosR - cornerDy * sinR;
                    const rotatedDy = cornerDx * sinR + cornerDy * cosR;

                    // Convert to lat/lon from cluster center
                    const lat = state.centerLat + (rotatedDy / METERS_PER_DEG_LAT);
                    const lon = state.centerLon + (rotatedDx / (METERS_PER_DEG_LON * Math.cos(state.centerLat * Math.PI / 180)));
                    return [lat, lon];
                });

                const polygon = L.polygon(cornerLatLngs, {
                    color: '#000000',
                    weight: 3,
                    fillColor: '#00d4ff',
                    fillOpacity: 0.1
                }).addTo(previewMap);
                boundaryPolygons.push(polygon);

                // Extend total bounds
                if (!allBounds) {
                    allBounds = polygon.getBounds();
                } else {
                    allBounds.extend(polygon.getBounds());
                }

                // Add sheet label for multi-map (at center of rotated sheet)
                if (state.multiMap.enabled && state.multiMap.count > 1) {
                    // Calculate label position using same rotation as polygon
                    const labelDx = unrotatedPos.dx;
                    const labelDy = unrotatedPos.dy;
                    const rotatedLabelDx = labelDx * cosR - labelDy * sinR;
                    const rotatedLabelDy = labelDx * sinR + labelDy * cosR;
                    const labelLat = state.centerLat + (rotatedLabelDy / METERS_PER_DEG_LAT);
                    const labelLon = state.centerLon + (rotatedLabelDx / (METERS_PER_DEG_LON * Math.cos(state.centerLat * Math.PI / 180)));

                    const label = L.marker([labelLat, labelLon], {
                        icon: L.divIcon({
                            className: 'sheet-label-icon',
                            html: `<div class="sheet-label">${sheet.name}</div>`,
                            iconSize: [40, 40],
                            iconAnchor: [20, 20]
                        })
                    }).addTo(previewMap);
                    sheetLabels.push(label);
                }
            });

            // For single map, show orientation arrow
            if (!state.multiMap.enabled || state.multiMap.count === 1) {
                const arrowLength = 600;
                const arrowWidth = 400;
                const arrowOffset = halfHeight - arrowLength - 200;
                const arrowAngleRad = state.bearingAtTop * Math.PI / 180;

                const tipDx = (arrowOffset + arrowLength) * Math.sin(arrowAngleRad);
                const tipDy = (arrowOffset + arrowLength) * Math.cos(arrowAngleRad);
                const baseCenterDx = arrowOffset * Math.sin(arrowAngleRad);
                const baseCenterDy = arrowOffset * Math.cos(arrowAngleRad);

                const perpAngle = arrowAngleRad + Math.PI / 2;
                const arrowHalfWidth = arrowWidth / 2;
                const baseLeft = {
                    dx: baseCenterDx + arrowHalfWidth * Math.sin(perpAngle),
                    dy: baseCenterDy + arrowHalfWidth * Math.cos(perpAngle)
                };
                const baseRight = {
                    dx: baseCenterDx - arrowHalfWidth * Math.sin(perpAngle),
                    dy: baseCenterDy - arrowHalfWidth * Math.cos(perpAngle)
                };

                const arrowPoints = [
                    [
                        state.centerLat + tipDy / METERS_PER_DEG_LAT,
                        state.centerLon + tipDx / (METERS_PER_DEG_LON * Math.cos(state.centerLat * Math.PI / 180))
                    ],
                    [
                        state.centerLat + baseLeft.dy / METERS_PER_DEG_LAT,
                        state.centerLon + baseLeft.dx / (METERS_PER_DEG_LON * Math.cos(state.centerLat * Math.PI / 180))
                    ],
                    [
                        state.centerLat + baseRight.dy / METERS_PER_DEG_LAT,
                        state.centerLon + baseRight.dx / (METERS_PER_DEG_LON * Math.cos(state.centerLat * Math.PI / 180))
                    ]
                ];

                orientationArrow = L.polygon(arrowPoints, {
                    color: '#000000',
                    weight: 2,
                    fillColor: '#ff6b6b',
                    fillOpacity: 0.9
                }).addTo(previewMap);
            }

            // Update or create center marker
            if (centerMarker) {
                centerMarker.setLatLng([state.centerLat, state.centerLon]);
            } else {
                centerMarker = L.circleMarker([state.centerLat, state.centerLon], {
                    radius: 8,
                    color: '#ff6b6b',
                    fillColor: '#ff6b6b',
                    fillOpacity: 1,
                    weight: 2
                }).addTo(previewMap);
            }

            // Fit map to all boundaries
            if (allBounds) {
                previewMap.fitBounds(allBounds, { padding: [50, 50] });
            }

            // Update statistics - calculate total coverage for multi-map
            let totalWidthM = widthM;
            let totalHeightM = heightM;

            if (state.multiMap.enabled && state.multiMap.count > 1) {
                if (state.multiMap.orientation === 'short_edge') {
                    totalWidthM = widthM * 2 - (1 * colSpacing);
                } else if (state.multiMap.orientation === 'long_edge') {
                    totalHeightM = heightM * 2 - (1 * rowSpacing);
                } else if (state.multiMap.orientation === 'grid') {
                    totalWidthM = widthM * 2 - (1 * colSpacing);
                    totalHeightM = heightM * 2 - (1 * rowSpacing);
                }
            }

            const coverageText = state.multiMap.enabled && state.multiMap.count > 1
                ? `${(totalWidthM/1000).toFixed(1)} x ${(totalHeightM/1000).toFixed(1)} km (${state.multiMap.count} maps)`
                : `${(widthM/1000).toFixed(1)} x ${(heightM/1000).toFixed(1)} km`;
            document.getElementById('statCoverage').textContent = coverageText;

            const rotationDisplay = state.bearingAtTop === 0
                ? '0¬∞ (North up)'
                : `${state.bearingAtTop}¬∞ (${bearingToDirection(state.bearingAtTop)} up)`;
            document.getElementById('statRotation').textContent = rotationDisplay;
        }

        /**
         * Get unrotated sheet positions relative to cluster center.
         * Used for preview rendering where we need to rotate corners around cluster center.
         */
        function getUnrotatedSheetPositions(count, orientation, widthM, heightM, overlapHexes) {
            if (count === 1 || orientation === 'single') {
                return [{ dx: 0, dy: 0 }];
            }

            const hexSizeM = getHexSizeM();
            const size = hexSizeM / Math.sqrt(3);
            const colSpacing = 1.5 * size;
            const rowSpacing = hexSizeM;
            const xOffset = widthM - (overlapHexes * colSpacing);
            const yOffset = heightM - (overlapHexes * rowSpacing);

            if (orientation === 'short_edge' && count === 2) {
                return [
                    { dx: -xOffset / 2, dy: 0 },
                    { dx: +xOffset / 2, dy: 0 }
                ];
            } else if (orientation === 'long_edge' && count === 2) {
                return [
                    { dx: 0, dy: +yOffset / 2 },
                    { dx: 0, dy: -yOffset / 2 }
                ];
            } else if (orientation === 'grid' && count === 4) {
                return [
                    { dx: -xOffset / 2, dy: +yOffset / 2 },
                    { dx: +xOffset / 2, dy: +yOffset / 2 },
                    { dx: -xOffset / 2, dy: -yOffset / 2 },
                    { dx: +xOffset / 2, dy: -yOffset / 2 }
                ];
            }
            return [{ dx: 0, dy: 0 }];
        }

        /**
         * Calculate sheet centers for multi-map layouts.
         * JavaScript equivalent of tactical_map.py:calculate_adjacent_centers()
         */
        function calculateSheetCenters(centerLat, centerLon, rotationDeg, count, orientation, widthM, heightM, overlapHexes) {
            if (count === 1 || orientation === 'single') {
                return [{ name: '', lat: centerLat, lon: centerLon }];
            }

            // Calculate overlap offset in meters using dynamic hex size
            const hexSizeM = getHexSizeM();
            const size = hexSizeM / Math.sqrt(3);
            const colSpacing = 1.5 * size;
            const rowSpacing = hexSizeM;

            // Offset between sheet centers (accounting for overlap)
            const xOffset = widthM - (overlapHexes * colSpacing);
            const yOffset = heightM - (overlapHexes * rowSpacing);

            // Define sheet positions relative to cluster center (0,0)
            let positions = [];
            if (orientation === 'short_edge' && count === 2) {
                // Side-by-side: A on left, B on right
                positions = [
                    { name: 'A', dx: -xOffset / 2, dy: 0 },
                    { name: 'B', dx: +xOffset / 2, dy: 0 }
                ];
            } else if (orientation === 'long_edge' && count === 2) {
                // Stacked: A on top, B on bottom
                positions = [
                    { name: 'A', dx: 0, dy: +yOffset / 2 },
                    { name: 'B', dx: 0, dy: -yOffset / 2 }
                ];
            } else if (orientation === 'grid' && count === 4) {
                // 2x2 grid: A=NW, B=NE, C=SW, D=SE
                positions = [
                    { name: 'A', dx: -xOffset / 2, dy: +yOffset / 2 },
                    { name: 'B', dx: +xOffset / 2, dy: +yOffset / 2 },
                    { name: 'C', dx: -xOffset / 2, dy: -yOffset / 2 },
                    { name: 'D', dx: +xOffset / 2, dy: -yOffset / 2 }
                ];
            } else {
                return [{ name: '', lat: centerLat, lon: centerLon }];
            }

            // Apply rotation to offset vectors
            const angleRad = rotationDeg * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            return positions.map(pos => {
                let dx = pos.dx;
                let dy = pos.dy;

                // Rotate offset by map rotation angle
                if (rotationDeg !== 0) {
                    const rotatedDx = dx * cosA - dy * sinA;
                    const rotatedDy = dx * sinA + dy * cosA;
                    dx = rotatedDx;
                    dy = rotatedDy;
                }

                // Convert meter offsets to lat/lon
                const lat = centerLat + (dy / METERS_PER_DEG_LAT);
                const lon = centerLon + (dx / (METERS_PER_DEG_LON * Math.cos(centerLat * Math.PI / 180)));

                return { name: pos.name, lat, lon };
            });
        }

        // Update preview when rotation changes
        const originalRotationHandler = document.getElementById('rotationSlider').oninput;
        document.getElementById('rotationSlider').addEventListener('input', (e) => {
            // The existing handler updates state.bearingAtTop
            // Now also update the preview
            setTimeout(updatePreviewBoundary, 0);
        });

        // Update preview when hex size changes
        document.getElementById('hexSizeM').addEventListener('input', (e) => {
            // Debounce to avoid too many updates while typing
            clearTimeout(window.hexSizeDebounce);
            window.hexSizeDebounce = setTimeout(updatePreviewBoundary, 300);
        });
    </script>
</body>
</html>
